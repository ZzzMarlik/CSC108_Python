'''This module should be used to give you style feedback, and to test the 
parameter and return types of your functions. Before submitting your assignment, 
run this typechecker. This typechecker expects to find files flight_reader.py, 
flight_functions.py, and flight_types_constants_and_test_data.py in its folder.

Fixing all style errors and warnings generated by the "coding style" part of 
this checker will ensure you get most of your style marks. 

If errors occur when you run this typechecker, fix them before you submit
your assignment.

If no errors occur when you run this typechecker, then the type checks passed.
This means that the function parameters and return types match the assignment
specification, but it does not mean that your code works correctly in all
situations. Be sure to test your code thoroughly before submitting.
'''

import sys

sys.path.insert(0, './pyta')


print("================= Start: checking coding style =================")

import python_ta
python_ta.check_all('flight_reader.py', config='pyta/a3_pyta.txt')
python_ta.check_all('flight_functions.py', config='pyta/a3_pyta.txt')

print("================= End: checking coding style =================\n")


print("================= Start: checking parameter and return types =================")

import builtins
import copy
from io import StringIO

import flight_reader
import flight_functions
import flight_types_constants_and_test_data as fdata

# Check for use of functions print and input.

our_print = print
our_input = input

def disable_print(*args):
    raise Exception("You must not call built-in function print!")

def disable_input(*args):
    raise Exception("You must not call built-in function input!")

builtins.print = disable_print
builtins.input = disable_input

# Type check the flight_reader.py functions

TYPECHECK_FEEBACK = 'The return type for {} should be {}, but your code returned {}'

# Type check flight_reader.read_airports
result = flight_reader.read_airports(StringIO(fdata.TEST_AIRPORTS_SRC))
assert isinstance(result, dict), \
    TYPECHECK_FEEBACK.format('read_airports', 'dict', type(result))
for key in result:
    assert isinstance(key, str), \
        TYPECHECK_FEEBACK.format('read_airports', 'dict with str keys', 'dict with ' + type(key) + ' keys') 
    assert isinstance(result[key], list), \
        TYPECHECK_FEEBACK.format('read_airports', 'dict with list values', 'dict with ' + type(result[key]) + ' values')  

# Type check flight_reader.read_routes
result = flight_reader.read_routes(
    StringIO(fdata.TEST_ROUTES_SRC), fdata.TEST_AIRPORTS_DICT)
assert isinstance(result, dict), \
    TYPECHECK_FEEBACK.format('read_routes', 'dict', type(result))
for key in result:
    assert isinstance(key, str), \
        TYPECHECK_FEEBACK.format('read_routes', 'dict with str keys', 'dict with ' + type(key) + ' keys') 
    assert isinstance(result[key], set), \
        TYPECHECK_FEEBACK.format('read_routes', 'dict with set values', 'dict with ' + type(result[key]) + ' values') 

# Type check the flight_functions.py functions

# Type check flight_functions.get_airport_info
airports = copy.deepcopy(fdata.TEST_AIRPORTS_DICT)
result = flight_functions.get_airport_info(airports, 'AA1', 'Timezone')
assert isinstance(result, str), \
    TYPECHECK_FEEBACK.format('get_airport_info', 'str', type(result))
assert airports == fdata.TEST_AIRPORTS_DICT, \
       'get_airport_info should not mutate the parameter'

# Type check flight_functions.is_direct_flight
routes = copy.deepcopy(fdata.TEST_ROUTES_DICT_FOUR_CITIES)
result = flight_functions.is_direct_flight('AA1', 'AA2', routes)
assert isinstance(result, bool), \
    TYPECHECK_FEEBACK.format('is_direct_flight', 'bool', type(result))
assert routes == fdata.TEST_ROUTES_DICT_FOUR_CITIES, \
       'is_direct_flight should not mutate the parameter'

# Type check flight_functions.is_valid_flight_sequence
routes = copy.deepcopy(fdata.TEST_ROUTES_DICT_FOUR_CITIES)
result = flight_functions.is_valid_flight_sequence(['AA3', 'AA2', 'AA1'], routes)
assert isinstance(result, bool), \
    TYPECHECK_FEEBACK.format('is_valid_flight_sequence', 'bool', type(result))
assert routes == fdata.TEST_ROUTES_DICT_FOUR_CITIES, \
       'is_valid_flight_sequence should not mutate the parameter'

# Type check flight_functions.count_outgoing_flights
routes = copy.deepcopy(fdata.TEST_ROUTES_DICT_FOUR_CITIES)
result = flight_functions.count_outgoing_flights('AA1', routes)
assert isinstance(result, int), \
    TYPECHECK_FEEBACK.format('count_outgoing_flights', 'int', type(result))
assert routes == fdata.TEST_ROUTES_DICT_FOUR_CITIES, \
       'count_outgoing_flights should not mutate the parameter'

# Type check flight_functions.count_incoming_flights
routes = copy.deepcopy(fdata.TEST_ROUTES_DICT_FOUR_CITIES)
result = flight_functions.count_incoming_flights('AA1', routes)
assert isinstance(result, int), \
    TYPECHECK_FEEBACK.format('count_incoming_flights', 'int', type(result))
assert routes == fdata.TEST_ROUTES_DICT_FOUR_CITIES, \
       'count_incoming_flights should not mutate the parameter'

# Type check flight_functions.reachable_destinations
routes = copy.deepcopy(fdata.TEST_ROUTES_DICT_FOUR_CITIES)
result = flight_functions.reachable_destinations('AA1', 0, routes)
assert isinstance(result, list), \
    TYPECHECK_FEEBACK.format('reachable_destinations', 'list', type(result))
assert isinstance(result[0], set), \
    TYPECHECK_FEEBACK.format('reachable_destinations', 'list of set', 'list of ' + type(result[0]))
assert routes == fdata.TEST_ROUTES_DICT_FOUR_CITIES, \
       'reachable_destinations should not mutate the parameter'

# Type check flight_functions.find_busiest_airports
routes = copy.deepcopy(fdata.TEST_ROUTES_DICT_FOUR_CITIES)
result = flight_functions.find_busiest_airports(routes, 3)
assert isinstance(result, list), \
    TYPECHECK_FEEBACK.format('find_busiest_airports', 'list', type(result))
assert isinstance(result[0], tuple), \
    TYPECHECK_FEEBACK.format('find_busiest_airports', 'list of tuple', 'list of ' + type(result[0]))
assert isinstance(result[0][0], str) and isinstance(result[0][1], int), \
    TYPECHECK_FEEBACK.format('find_busiest_airports', 
                             'list of tuple of (str, int)', 
                             'list of tuple of (' + type(result[0][0]) + ', ' + \
                             type(result[0][1]) + ')')
assert routes == fdata.TEST_ROUTES_DICT_FOUR_CITIES, \
       'find_busiest_airports should not mutate the parameter'

builtins.print = our_print
builtins.input = our_input

print("================= End: checking parameter and return types =================\n")

print("The parameter and return type checker passed.")
print("This means we will be able to test your code.")
print("It does NOT mean your code is necessarily correct.")
print("You should run your own thorough tests to convince yourself your code is correct.")
print()
print("Scroll up to review the output of checking coding style.")
print("Make sure you scroll all the way to the top to see style checking for both files")